import HB from 'handlebars';
import {existsSync, readFileSync, writeFile} from 'fs';
import {join, resolve} from 'path';
import consola from 'consola';
import type {templateData, templates} from '../types.js';
import {fileURLToPath} from 'url';

const fileExtention = 'template.hbs';

const __dirname = fileURLToPath(new URL('.', import.meta.url));

const format = (i: number) => {
  return i < 10 ? `0${i}` : i;
};

const getCurrentYYYYMMDDHHmms = () => {
  const date = new Date();
  return [
    date.getUTCFullYear(),
    format(date.getUTCMonth() + 1),
    format(date.getUTCDate()),
    format(date.getUTCHours()),
    format(date.getUTCMinutes()),
    format(date.getUTCSeconds()),
  ].join('');
};

const generateFileName = (
  templateName: templates,
  {tableName, columnName}: templateData,
  fileExtention?: string
) => {
  const ts = getCurrentYYYYMMDDHHmms();
  const separator = '-';
  switch (templateName) {
    case 'createTable':
      return [ts, 'create', tableName].join(separator) + fileExtention;
    case 'removeTable':
      return [ts, 'remove', tableName].join(separator) + fileExtention;
    case 'addColumn':
      return (
        [ts, 'add', columnName, 'to', tableName].join(separator) + fileExtention
      );
    case 'removeColumn':
      return (
        [ts, 'remove', columnName, 'from', tableName].join(separator) +
        fileExtention
      );
    case 'modifyColumn':
      return (
        [ts, 'modify', columnName, 'on', tableName].join(separator) +
        fileExtention
      );
    default:
      return [ts, 'migration'].join(separator) + fileExtention;
  }
};

const sleep = async (ms: number) =>
  new Promise(res => {
    setTimeout(() => {
      res(true);
    }, ms);
  });

const renderTemplate = async (
  templateName: templates,
  data: templateData,
  migrationsPath: string,
  extension?: string
): Promise<boolean> => {
  await sleep(1000);
  return new Promise((res, rej) => {
    const templatePath = resolve(
      __dirname,
      '../../templates',
      `${templateName}.${fileExtention}`
    );

    if (!existsSync(templatePath)) {
      rej('Template not found ' + templatePath);
    }
    HB.registerHelper(
      'formatAttributes',
      (arg1: {[k: string]: unknown}, indent: string) => {
        const formatValue = (key: string, value: unknown): string => {
          if (key === 'type') {
            return `Sequelize.${value}`;
          }
          switch (typeof value) {
            case 'string':
              return `'${value}'`;
            case 'object':
              return JSON.stringify(value)
                .replace(/"([^"]+)":/g, '$1:')
                .replace(/"/g, "'");
            default:
              return `${value}`;
          }
        };
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const {Model, _modelAttribute, field, _autoGenerated, ...rest} = arg1;
        return (
          Object.keys(rest)
            .filter(k => typeof rest[k] !== 'function')
            .map(a => `${a}: ${formatValue(a, arg1[a])}`)
            .join(`,\n${new Array(parseInt(indent)).fill(' ').join('')}`) + ','
        );
      }
    );
    const template = HB.compile(readFileSync(templatePath).toString());
    const content = template(data);
    const fileName = generateFileName(templateName, data, extension);
    writeFile(join(migrationsPath, fileName), content, () => {
      consola.success(fileName, 'Created!');
      res(true);
    });
  });
};

export default renderTemplate;
